package services

import (
	"context"
	"fmt"
	"time"

	"cloud.google.com/go/firestore"
	"github.com/google/uuid"
)

const (
	galleryDevCollection  = "gallery_dev"
	galleryProdCollection = "gallery_prod"
	defaultGalleryLimit   = 5
)

type Gallery struct {
	Name        string    `json:"name" firestore:"name"`
	Aspect      string    `json:"aspect" firestore:"aspect"`
	Count       int       `json:"count" firestore:"count"`
	Views       []string  `json:"views" firestore:"views"`
	Tags        []string  `json:"tags" firestore:"tags"`
	ID          string    `json:"id" firestore:"id"`
	DateAdded   time.Time `json:"date_added" firestore:"date_added"`
	DateCreated time.Time `json:"date_created" firestore:"date_created,omitempty"`
}

type GalleryService struct {
	db         *firestore.Client
	collection string
}

type GalleryQueryInput struct {
	Tags   []string  `url:"tags"`
	Aspect string    `url:"filetype"`
	Limit  int       `url:"limi"`
	Offset time.Time `url:"offset"`
}

type GalleryQueryOutput struct {
	Offset time.Time
	Items  []*Gallery
}

func NewGalleryService(stage string) (*GalleryService, error) {

	ctx := context.Background()

	// Get a client
	db, err := firestore.NewClient(ctx, "nykelab")
	if err != nil {
		return nil, err
	}

	if stage == "dev" {
		return &GalleryService{db, galleryDevCollection}, nil
	}
	return &GalleryService{db, galleryProdCollection}, nil
}

// Creates a record and returns the ID
func (gs *GalleryService) Create(m *Gallery) (*string, error) {

	// ID id generated by backend
	m.ID = uuid.New().String()
	m.DateAdded = time.Now()

	docRef := gs.db.Collection(gs.collection).Doc(m.ID)

	_, err := docRef.Create(context.Background(), m)

	if err != nil {
		return nil, err
	}

	return &m.ID, nil
}

// Given the ID, this will apply the passed in updates
func (gs *GalleryService) Update(id string, updates *[]firestore.Update) error {

	docRef := gs.db.Collection(gs.collection).Doc(id)

	_, err := docRef.Update(context.Background(), *updates)

	if err != nil {
		return err
	}

	return nil
}

// Given the ID, this will apply the passed in updates
func (gs *GalleryService) Query(q *GalleryQueryInput) (*GalleryQueryOutput, error) {

	var galleryItems []*Gallery

	// Check for pagination token
	if !q.Offset.IsZero() {
		//  Check to see if limit was supplied, if not will apply default
		if q.Limit == 0 {
			q.Limit = defaultGalleryLimit
		}
		var query firestore.Query

		collRef := gs.db.Collection(gs.collection)

		// Check to see if filetype were supplied
		if q.Aspect != "" {
			query = collRef.Where("aspect", "==", q.Aspect).Limit(q.Limit).StartAfter(q.Offset)
		}

		// Check to see if tags were suppleid
		if q.Tags != nil {
			if q.Aspect != "" {
				query = query.Where("tags", "array-contains-any", q.Tags).Limit(q.Limit).StartAfter(q.Offset).OrderBy("date_added", firestore.Desc)
			} else {
				query = collRef.Where("tags", "array-contains-any", q.Tags).Limit(q.Limit).StartAfter(q.Offset).OrderBy("date_added", firestore.Desc)
			}
		} else {

			// Since no filter paramters were specified, we will just query the entire document
			query := collRef.OrderBy("date_added", firestore.Desc).Limit(q.Limit)
			queryResults, err := query.Documents(context.Background()).GetAll()

			if err != nil {
				return nil, err
			}

			if len(queryResults) == 0 {
				return nil, fmt.Errorf("Received 0 results for query\nTYPE:%s\nTAGS:%v\n", q.Aspect, q.Tags)
			}

			// Convert the snapshots into gallery structs
			for _, v := range queryResults {
				var m Gallery
				v.DataTo(&m)
				galleryItems = append(galleryItems, &m)
			}

			// Grab the timestamp of the last retuned doc for offset
			offset := galleryItems[len(galleryItems)-1].DateAdded

			return &GalleryQueryOutput{Offset: offset, Items: galleryItems}, nil
		}

		// Run the Query
		queryResults, err := query.Documents(context.Background()).GetAll()

		if err != nil {
			return nil, err
		}

		if len(queryResults) == 0 {
			return nil, fmt.Errorf("Received 0 results for query\nTYPE:%s\nTAGS:%v\n", q.Aspect, q.Tags)
		}

		// Convert the snapshots into gallery structs
		for _, v := range queryResults {
			var m Gallery
			v.DataTo(&m)
			galleryItems = append(galleryItems, &m)
		}

		// Grab the timestamp of the last retuned doc for offset
		offset := galleryItems[len(galleryItems)-1].DateAdded

		return &GalleryQueryOutput{Offset: offset, Items: galleryItems}, nil
	}

	//  Check to see if limit was supplied, if not will apply default
	if q.Limit == 0 {
		q.Limit = defaultGalleryLimit
	}
	var query firestore.Query

	collRef := gs.db.Collection(gs.collection)

	// Check to see if filetype were supplied
	if q.Aspect != "" {
		query = collRef.Where("filetype", "==", q.Aspect).Limit(q.Limit)
	}

	// Check to see if tags were suppleid
	if q.Tags != nil {

		if q.Aspect != "" {
			query = query.Where("tags", "array-contains-any", q.Tags).Limit(q.Limit)
		}
		query = collRef.Where("tags", "array-contains-any", q.Tags).Limit(q.Limit)
		queryResults, err := query.Documents(context.Background()).GetAll()

		if err != nil {
			return nil, err
		}

		if len(queryResults) == 0 {
			return nil, fmt.Errorf("Received 0 results for query\nTYPE:%s\nTAGS:%v\n", q.Aspect, q.Tags)
		}

		// Convert the snapshots into gallery structs
		for _, v := range queryResults {
			var m Gallery
			v.DataTo(&m)
			galleryItems = append(galleryItems, &m)
		}

		// Grab the timestamp of the last retuned doc for offset
		offset := galleryItems[len(galleryItems)-1].DateAdded

		return &GalleryQueryOutput{Offset: offset, Items: galleryItems}, nil
	} else {

		// Since no filter paramters were specified, we will just query the entire document
		query := collRef.OrderBy("date_added", firestore.Desc).Limit(q.Limit)
		queryResults, err := query.Documents(context.Background()).GetAll()

		if err != nil {
			return nil, err
		}

		if len(queryResults) == 0 {
			return nil, fmt.Errorf("Received 0 results for query\nTYPE:%s\nTAGS:%v\n", q.Aspect, q.Tags)
		}

		// Convert the snapshots into gallery structs
		for _, v := range queryResults {
			var m Gallery
			v.DataTo(&m)
			galleryItems = append(galleryItems, &m)
		}

		// Grab the timestamp of the last retuned doc for offset
		offset := galleryItems[len(galleryItems)-1].DateAdded

		return &GalleryQueryOutput{Offset: offset, Items: galleryItems}, nil
	}

}
